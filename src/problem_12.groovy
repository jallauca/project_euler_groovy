// Highly divisible triangular number (Problem 12) (https://projecteuler.net/problem=12)

// The sequence of triangle numbers is generated by adding the natural numbers.
// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
// ten terms would be:

// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

// Let us list the factors of the first seven triangle numbers:

//  1: 1
//  3: 1,3
//  6: 1,2,3,6
// 10: 1,2,5,10
// 15: 1,3,5,15
// 21: 1,3,7,21
// 28: 1,2,4,7,14,28
// We can see that 28 is the first triangle number to have over five divisors.

// What is the value of the first triangle number to have over five hundred divisors?

// Solution Tips:
// From http://en.wikipedia.org/wiki/Prime_number:

//   Fundamental theorem of arithmetic
//   Main article: Fundamental theorem of arithmetic
//   The fundamental theorem of arithmetic states that every integer larger than
//   1 can be written as a product of one or more primes in a way that is unique
//   except for the order of the prime factors.
//   For example:

//   23244	= 2 · 2 · 3 · 13 · 149
//          = 2^2   · 3 · 13 · 149

// Using the fundamental theorem of arithmetic, a number like 28 is written
//    28    = 2 * 2 * 7
//            2^2   * 7

// I discovered that the factors of a number can be obtained from the prime
// number factors by multiplying every number in the 1-k, 2-k, 3-k, ..., n-k
// combinations, where n = number of prime factors

// So, 28 has the following 1-k, 2-k, 3-k combinations out of its 3 prime factors:
// 28 = [[[2],[2],[7]],           # 1-k
//       [[2,2],[2,7],[2,7]],     # 2-k
//       [[2,2,7]]]               # 3-k

// The combinations' products are:
// 28 = [[[2],[2],[7]],
//       [[4],[14],[14]],
//       [28]]

// Therefore, the factors for 28, after removing duplicates and adding
// number 1 (which is not prime) to the list, are:
// 28 = [1,2,4,7,14,28]

package project.euler.problems

class Problem_12 {
  Problem_12(int divisorCount) {
    this.divisorCount = divisorCount
    IterableMonkeyPatch.apply()
  }

  int divisorCount

  static void main(String[] args) {
    def answer = new Problem_12(500).run()
    assert answer==76576500
    println("answer=$answer")
  }

  def run() {
    if (divisorCount < 1) return 0
    if (divisorCount == 1) return 1

    def generator = new TriangleNumberGenerator()
    generator.next() // Skip #1

    def answer
    while ( !answer ) {
      def triangleNumber = generator.next()
      def prime_factors = PrimeNumber.prime_factors(triangleNumber)

      def combinationIsUnique = factorsCombinationIsUnique(prime_factors)
      if ( prime_factors.size() > 8 && combinationIsUnique ) {
        def factors = PrimeNumber.factors(triangleNumber)
        if ( factors.size() >= divisorCount ) { answer = triangleNumber }
      }
    }
    answer
  }

  def uniqueCounts = [""] as Set
  boolean factorsCombinationIsUnique(List<Long> prime_factors) {
    def counts = prime_factors.countBy { it }.collect { k, v -> v }.sort().toString()
    def isUnique = !(counts in uniqueCounts)
    if (isUnique) { uniqueCounts << counts }
    isUnique
  }

  long factorial(int n) {
    if ( n == 0 ) return 1
    (1..n).inject(1) { product, value -> product * value }
  }
}
